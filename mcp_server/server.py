import asyncio
import json
import os
from pathlib import Path

import anthropic
import mcp.types as types
from mcp.server import Server
from mcp.server.stdio import stdio_server

server = Server("COD Document Server")

# ---------------------------------------------------------------------------
# Data paths
# ---------------------------------------------------------------------------

_MOCK_DATA_DIR = Path(__file__).parent.parent / "mock_data"
_SEARCH_RESPONSE_FILE = _MOCK_DATA_DIR / "search_response.json"
_DOCUMENTS_DIR = _MOCK_DATA_DIR / "documents"

# ---------------------------------------------------------------------------
# Data loaders
# ---------------------------------------------------------------------------

def _load_search_index() -> dict[str, list[dict]]:
    with _SEARCH_RESPONSE_FILE.open() as f:
        return json.load(f)

def _load_document_text(document_id: str) -> str | None:
    path = _DOCUMENTS_DIR / f"{document_id}.txt"
    if not path.exists():
        return None
    return path.read_text()


# ---------------------------------------------------------------------------
# Tool handlers
# ---------------------------------------------------------------------------

@server.list_tools()
async def list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="search",
            description=(
                "Search for documents associated with a veteran participant ID. "
                "Returns a list of document metadata records. Use retrieve_text_content "
                "with a document_id to fetch the full text of any document."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "participant_id": {
                        "type": "string",
                        "description": "The veteran's participant/ICN identifier.",
                    }
                },
                "required": ["participant_id"],
            },
        ),
        types.Tool(
            name="retrieve_text_content",
            description="Retrieve the full text content of a document by its document_id.",
            inputSchema={
                "type": "object",
                "properties": {
                    "document_id": {
                        "type": "string",
                        "description": "The document_id returned by search.",
                    }
                },
                "required": ["document_id"],
            },
        ),
        types.Tool(
            name="summarize_document",
            description=(
                "Retrieve a document by its document_id and return a COD-focused summary "
                "generated by an AI model. The summary extracts only content relevant to "
                "Character of Discharge determination: disciplinary actions, mental health "
                "references, discharge circumstances, mitigating factors, and "
                "awards/commendations."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "document_id": {
                        "type": "string",
                        "description": "The document_id returned by search.",
                    }
                },
                "required": ["document_id"],
            },
        ),
    ]


@server.call_tool()
async def call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    if name == "search":
        participant_id = arguments["participant_id"]
        index = _load_search_index()
        results = index.get(participant_id, [])
        return [types.TextContent(type="text", text=json.dumps(results, indent=2))]

    if name == "retrieve_text_content":
        document_id = arguments["document_id"]
        text = _load_document_text(document_id)
        if text is None:
            return [types.TextContent(type="text", text=f"Error: document '{document_id}' not found.")]
        return [types.TextContent(type="text", text=text)]

    if name == "summarize_document":
        document_id = arguments["document_id"]
        text = _load_document_text(document_id)
        if text is None:
            return [types.TextContent(type="text", text=f"Error: document '{document_id}' not found.")]

        prompt = (
            "You are a VA claims assistant specializing in Character of Discharge (COD) determinations. "
            "Review the following document and extract ONLY content relevant to a COD determination. "
            "Focus on:\n"
            "- Disciplinary actions (Article 15s, court-martial, counseling statements, letters of reprimand)\n"
            "- Mental health references (referrals, diagnoses, treatment history, behavioral concerns)\n"
            "- Discharge circumstances (reason, authority, AWOL details, separation proceedings)\n"
            "- Mitigating factors (combat service, voluntary surrender, stressors, extenuating circumstances)\n"
            "- Awards and commendations (character evidence)\n\n"
            "If the document contains no COD-relevant content, state that explicitly.\n"
            "Be concise and factual. Cite specific dates and details where present.\n\n"
            f"DOCUMENT:\n{text}"
        )

        api_key = os.environ.get("ANTHROPIC_API_KEY")
        if not api_key:
            return [types.TextContent(type="text", text="Error: ANTHROPIC_API_KEY environment variable not set.")]

        client = anthropic.Anthropic(api_key=api_key)
        message = client.messages.create(
            model="claude-haiku-4-5-20251001",
            max_tokens=1024,
            messages=[{"role": "user", "content": prompt}],
        )
        summary = message.content[0].text
        return [types.TextContent(type="text", text=summary)]

    raise ValueError(f"Unknown tool: {name}")


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

async def main() -> None:
    async with stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            server.create_initialization_options(),
        )


if __name__ == "__main__":
    asyncio.run(main())
